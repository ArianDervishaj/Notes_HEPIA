---
title: Directories (répertoires)
draft: false
tags:
  - SysExploitation
---

# Définition

- organisent les fichiers sous la forme d'une **arborescence**
- est représenté par un [[Inodes|inode]], dont le contenu est une liste d'entrées [[#Structure **dirent**|dirent]] (directory entries), qui associent chaque nom de fichier ou de sous-répertoire à son inode.
- chaque **dirent** contient au moins `.` et `..` 

![[Pasted image 20241007092426.png]]

--- 
# Répertoire courant

Chaque processus possède un **répertoire courant** qui permet d'interpréter les **chemins relatifs**. 

Le **répertoire courant** est celui depuis lequel le programme est lancé, il peut être différent du répertoire ou l'exécutable est.

### Exemple
- Vous êtes dans le répertoire `/home/utilisateur/projets` et vous lancez un programme depuis ce répertoire.
- Le répertoire courant du programme sera `/home/utilisateur/projets`, même si l'exécutable du programme se trouve dans `/usr/bin`.
- Donc, si le programme doit accéder à un fichier en utilisant un chemin relatif, il le cherchera dans `/home/utilisateur/projets`, pas dans `/usr/bin`.

## Connaitre le répertoire courant

```c
char *getcwd(char *buf, size_t size);
# buf  : chaîne de caractère qui contiendra le répertoire courant
# size : taille du buffer
# retourne NULL en cas d'erreur, l'adresse de buf sinon.
```

> [!info] Library
> Ne pas oublier `#include <unistd.h>` (écrit dans le man)

## Changer le répertoire courant

```c
int chdir(const char *path);
# path : chaine de caractère indiquant le nouveau répertoire (relatif ou absolu)
# retourne -1 si erreur, 0 sinon
```

---
# Structure **dirent**

```c
struct dirent {                  /* dirent.h */
    # inode number
    ino_t d_ino;               
    
	# opaque value used to get next dirent (do not use)
    off_t d_off;               

	# length of this record 
    unsigned short d_reclen;    
    
    # type of file; not supported by all file systems 
    unsinged char d_type;      

	# filename (NULL terminated), sometimes d_name[0] 
    char d_name[256]; 
};
```

Seulement les champs **d_ino** et **d_name** sont décrit par POSIX.

> [!warning] Attention 
> ne jamais compter sur la taille du tableau d_name. 
> Se baser sur la constante **MAX_NAME** ou `strlen`

> [!info] Retrouver la structure dans le man
> `man 3 readdir`
## Champs d_type

champs de bits content des infos sur le type de l'inode

| FLAG       | DESCRIPTION        |
| ---------- | ------------------ |
| DT_DIR     | Répertoire         |
| DT_LNK     | Lien symbolique    |
| DT_REG     | Fichier de données |
| DT_UNKNOWN | Type incconu       |

> [!info] Voir tous les flags
> `man readdir`

> [!WARNING] Ne pas toujours se fier au champ d_type
> Tous les systèmes de fichier ne prennent pas en charge le remplissage de ce champ.
> Si le d_type vaut DT_UNKNOWN, faire un appel supplémentaire comme [[Inodes#Récupérer les métadonnées d'un fichier|stat( )]] ou [[Inodes#Récupérer les métadonnées d'un symlink|lstat( )]].

---
# Flot de répertoires

Pour accéder aux entrés d'un répertoire, il faut :
1. Ouvrir le répertoire avec `opendir()`
2. Lire le répertoire avec `readdir()`
3. Répéter `readdir()` jusqu'à épuisement des entrées ou autre critère.
4. Fermer le répertoire avec `closedir()`

> [!info] Note
> Les fonctions ci-dessus ne sont pas des appels systèmes. 
> Pour manipuler les dossiers avec des appels système il faut utiliser les appels `open` et `getdents`.
> En pratique, on utilise les fonctions ci-dessus.
## Ouvrir un répertoire (`opendir()`)

```c
DIR *opendir(const char *name);
DIR *fdopendir(int fd);
# DIR est un type opaque
# En cas d'erreur DIR = NULL
```
### Example de code d'erreurs

| ERREUR  | DESCRIPTION                                   |
| ------- | --------------------------------------------- |
| EACCES  | Opération interdite (permissions)             |
| ENOENT  | Le répertoire n'existe pas ou le nom est vide |
| ENOTDIR | Le nom existe mais n'est pas un répertoire    |

> [!info] Voir les autres erreurs
> `man opendir`
## Lire l'entrée suivante (`readdir`)

```c
struct dirent *readdir(DIR *dirp);
# Retourne NULL, si plus d'entrée ou en cas d'erreur
# Sinon retourne un pointeur sur une instance de la structure dirent
```

**Un seul code d'erreur** : EBADF si le descripteur dirp n'est pas valide

> [!Warning] Attention
> La structure retournée peut être modifiée par chaque appel.
> Ne jamais free le pointeur retourné
> `readdir` n'est pas thread-safe
## Fermer un répertoire (`closedir`)

```c
int closedir(DIR *dirp);
# retourne 0 si succès, -1 sinon
```

**Un seul code d'erreur** : EBADF si le descripteur dirp n'est pas valide
## Example d'utilisation des trois fonctions.

```c
#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <string.h>  //snprintf
#include <errno.h> 
#include <dirent.h>
#include <limits.h>  //PATH_MAX

static void list_dir (const char * dir_name){

  DIR *d = opendir(dir_name);
  struct dirent *entry;
  const char *d_name;   // nom d'une entrée
   
  //En cas d'erreur d'ouverture
  if (! d) {
    fprintf(stderr, "Cannot open directory '%s': %s\n",
	     dir_name, strerror(errno));
    exit(EXIT_FAILURE);
  }
  
  //Boucle sur chaque entrée
  while( (entry = readdir(d)) != NULL ) {

    // Obtient le nom de l'entrée et affiche
    d_name = entry->d_name;
    printf("%s/%s\n", dir_name, d_name);

    //Est-ce que 'entry' est un sous-répertoire
    if (entry->d_type & DT_DIR) {
      //Est-ce que 'entry' n'est pas '..' ou '.'
      if (strcmp(d_name, "..") != 0 && strcmp(d_name, ".") != 0) {
	char path[PATH_MAX];

	//forme le nom du sous-répertoire et affiche
	int path_length = snprintf (path, PATH_MAX,
				    "%s/%s", dir_name, d_name);
	printf("%s\n", path);

	//Vérifie que le nom du sous-répertoire n'est pas trop long
	if (path_length >= PATH_MAX) {
	  fprintf(stderr, "Path length has got too long.\n");
	  exit(EXIT_FAILURE);
	}

	//Appel récursif
	list_dir(path);
      }
    }
  } //while(1)

  //On ferme le répertoite
  if( closedir(d) ) {
    fprintf(stderr, "Could not close '%s': %s\n",
	    dir_name, strerror (errno));
    exit (EXIT_FAILURE);
  }
}

int main () {
  list_dir("/var/log/");
  return EXIT_SUCCESS;
}
```
## Créer un répertoire (`mkdir`)

```c
int mkdir(const char *pathname, mode_t mode);
# pathname est le nom du répertoire
# mode est les permissions à utiliser
# retourne 0 si succès, -1 sinon
```

> [!info] Erreurs
> `man 2 mkdir`

> [!info] Voir les modes
> Les modes sont ceux de la structure [[Inodes#Déterminer les permissions d'un inode| STAT]]
## Effacer un répertoire (`rmdir`)

```c
int rmdir(const char *pathname);
# retourne 0 si succès, -1 sinon
```

> [!info] Erreurs
> `man 2 rmdir`

---