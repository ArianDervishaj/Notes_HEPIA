---
title: Inodes
draft: false
tags:
  - SysExploitation
---

# Définition

![[Pasted image 20241006154009.png]]

Le triplet (link, inode, data) est un fichier.

**Inode** : structure de donnée contenant des infos sur un "fichier" (fichier, directory, socket, device, pipe etc).
**Ne contient pas le nom du fichier.**
Contient généralement (**POSIX**) des infos sur :
- Numéro d'inode
- Périphérique content le fichier (**Device ID**)
- Propriétaire et groupe
- Permissions
- Taille du fichier
- Temps d'accès et de modification
- Nombre de liens pointant vers l'inode
- **Pointeurs vers les données**
## Temps de l'inode

L'inode contient trois temps différents :
1. **atime** date du dernier accès à l'inode (ou aux données)
2. **mtime** : date de la dernière modif des données
3. **ctime** : date de la dernière modifs des méta-données
4. ***crtime*** : date de création du fichier (**NON POSIX**)

> [!info] Performance
> Pour gagner en perf, possible de désactiver la mise à jour de *atime* lorsque la partition est montée
## Inspecter un inode en shell

La command `stat`permet d'afficher des données sur un inode.

![[Pasted image 20241006154627.png]]

---
# Hard link (lien dur)

![[Pasted image 20241006154655.png]]

- Les entrés des répertoires sont des liens pointant vers des inodes.
- Peut avoir plusieurs liens vers un fichier.
- Un fichier est *effacé* lorsqu'il n'y a plus de liens pointant sur son inode (sauf si un process maintient le fichier ouvert. D'où l'importance de s'avoir le nombre de liens pointant vers l'indoe.
## Créer un hard link

La commande `ln`permet de créer un lien dur.

![[Pasted image 20241006154950.png]]

> [!warning] Limitations
>
⚠ **Un répertoire ne peux avoir qu'un seul lien dur.** Tous les liens durs pointant sur un inode doivent être sur le même système de fichier que celui ci.

> [!info] Information
> Peu utile d'avoir plusieurs liens durs vers un fichier. (Préférer les [[Inodes#Symlink (Lien symbolique)|liens symboliques]])
 ---
# Symlink (Lien symbolique)

![[Pasted image 20241006155318.png]]

- Un lien symbolique **possède son propre inode qui pointe vers un nom**
- Contrairement aux hardlinks, on peut créer des symlinks vers :
	- un répertoire
	- un fichier/répertoire sur un autre FS (file system)
## Créer un symlink

La commande `ln -s`permet de créer un symlink

![[Pasted image 20241006155628.png]]

---
# Lost+Found (objets trouvés)

A la suite d'une erreur du FS (*ex : mise hors-tension brutale*), un inode peut se retrouver sans liens.
Si cela se produit, alors lors d'*un contrôle de fichier* `fsck`, il sera copié dans le répertoire **lost+found** à la racine du FS.

---
# Structure STAT (sys/stat.h)

```c
struct stat{
  dev_t     st_dev;     //device ID
  ino_t     st_ino;     //i-node number
  mode_t    st_mode;    //protection and type
  nlink_t   st_nlink;   //number of hard links
  uid_t     st_uid;     //user ID of owner
  gid_t     st_gid;     //group ID of owner
  dev_t     st_rdev;    //device type (if special file)
  off_t     st_size;    //total size, in bytes
  blksize_t st_blksize; //blocksize for filesystem I/O
  blkcnt_t  st_blocks;  //number of 512B blocks
  time_t    st_atime;   //time of last access
  time_t    st_mtime;   //time of last modification
  time_t    st_ctime;   //time of last change
};
```


> [!Info] Retrouver dans le man
> `man 2 stat`

---
## Déterminer le type d'un inode

Le champ **st_mode** est un champ de bits contenant les permissions et le type de l'inode.
Macro POSIX pour tester les types :

|    Macro    |    Significations    |
| :---------: | :------------------: |
| S_ISREG(m)  | fichier de données ? |
| S_ISDIR(m)  |     répertoire ?     |
| S_ISCHR(m)  |  character device ?  |
| S_ISBLK(m)  |    block device ?    |
| S_ISFIFO(m) | FIFO (named pipe) ?  |
| S_ISLINK(m) |  lien symbolique ?   |
| S_ISSOCK(m) |       socket ?       |
### Exemple
```c
if( S_ISDIR( info.st_mode ) ) {
    printf( "L'inode est un repertoire.\n" );
}
```


> [!Info] Retrouver ces infos dans le man
> `man 7 inode`
## Déterminer les permissions d'un inode

| MACRO   | CHAMPS DE BITS | DESCRIPTIONS                   |
| ------- | :------------: | ------------------------------ |
| S_IRUSR |     00400      | owner has read permission      |
| S_IWUSR |     00200      | owner has write permission     |
| S_IXUSR |     00100      | owner has execute permission   |
| S_IRGRP |     00040      | group has read permission      |
| S_IWGRP |     00020      | group has write permission     |
| S_IXGRP |     00010      | group has execute permission   |
| S_IROTH |     00004      | others have read permission    |
| S_IWOTH |     00002      | others have write permission   |
| S_IXOTH |     00001      | others have execute permission |

> [!Info] Retrouver ces infos dans le man
> `man 7 inode`

---
# Appels systèmes
## Créer des liens
### Hard links
```c
int link(const char *old_path, const char *new_path); 
# old_path est le nom existant
# new_path est le nouveau nom
# retourne 0 si succès et -1 si erreur
# si new_path existe déjà => code d'erreur EEXIST
```

### Symlink
```c
int symlink(const char *old_path, const char *new_path);
# utilisation identique à link()
```

## Effacer un lien / un nom de fichier
```c
int unlink(const char *path_name);
# path_name est le nom à supprimer
# retourne 0 si succès et -1 si erreur.
```


> [!Tip] Codes d'erreurs
> voir `man 2 unlink`

## Récupérer les métadonnées d'un fichier
```c
int stat(const char *path, struct stat *buf);
# retourne 0 si succès et -1 si erreur
```

### Exemple
```c
struct stat infos;
char *filename = "/tmp/foo.txt";
if( stat( filename, &infos ) < 0 )
    fprintf( stderr, "Cannot stat %s: %s\n", filename, strerror(errno) );
else
    printf( "Filesize: %d\n", infos.st_size );
```

## Récupérer les métadonnées d'un symlink

Si A est un lien symbolique vers B `stat("A",...)` retourne les infos sur l'inode de B.
Pour éviter ce comportement et récupéré les infos sur le lien symbolique A alors on peut utiliser `lstat`.

```c
int lstat(const char *path, struct stat *buf);
```

## Récupérer les métadonnées d'un fichier ouvert

```c
int fstat(int fd, struct stat *buf);
```

## Voir les droits d'un processus en cours

Le test se fait en fonction de l'utilisateur/groupe courant.
```c
int access(const char *pathname, int mode); 
# retourne 0 si réussit, -1 sinon
```

**mode** est un champ de bit formés des flags :

| FLAG | DESCRIPTION        |
| ---- | ------------------ |
| R_OK | lecture possible   |
| W_OK | écriture possible  |
| X_OK | exécution possible |
| F_OK | fichier existe     |

> [!info] F_OK précision
> Le flag *F_OK* ne peut être testé que tout seul !

### Exemple
```c
char *fn = "/tmp/foo.txt";
if ( access( fn, R_OK|W_OK ) == 0 )
    printf( "On peut lire et ecrire sur %s\n", fn );
else if ( errno == EACCES )
    printf("Pas le droit de lire et/ou d'ecrire sur %s\n", fn);
else
    perror( fn );
```

## Changer les permissions
```c
int chmod(const char *path, mode_t mode);

# Utilise un descriptieur de fichier ouvert
int fchmod(int fd, mode_t mode);
```

**mode** est un champ de bits formés des mêmes flags que le st_mode de la [[Inodes#Structure STAT (sys/stat.h)|structure STAT]]

---
