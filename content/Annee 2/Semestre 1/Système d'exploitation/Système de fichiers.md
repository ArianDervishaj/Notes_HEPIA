---
title: Système de fichiers
draft: false
tags:
  - SysExploitation
---

# Disques durs mécanique (HDD)

- Adressage physique CHS remplacé par adressage logique : LBA (Logical Block Addressing)
- taille physique d'un secteur souvent 4kB avec émulation à 512 bytes par le firmware
# Disques durs à base de flash (SSD)

Sans partie mécanique mais présente des secteurs de 512 bytes adressés logiquement en LBA (comme [[Système de fichiers#Disques durs mécanique (HDD)|les HDD]])
# Structure d'un disque

Un disque est divisé en unité de taille identique appelées **secteurs**.
Un **secteur** : est la plus petite unité physique pouvant être lue ou écrite (par des opérations **atomiques**). 
La taille d'un secteur dépend support: **512 bytes**, 2kB, **4kB**, etc...

![[Pasted image 20241008140226.png]]
# UNIX et Blocs

Dans un OS de type UNIX, on parle de **blocs** (Microsoft appelle ça un **cluster**) plutôt que de secteurs.
Tout périphérique dont on peut lire/écrire les données par unités de 512,1024,... bytes est géré par le noyau de gestion de lecture/écriture par blocs

La taille d'un bloc est potentiellement plus grande que la taille d'un secteur
Permet d'être indépendant du type de périphérique => **généricité**
# Secteurs, blocs et clusters

**Un bloc** est une **collection contiguë de secteurs**
Un système de fichiers (FS) divise l'espace disque en blocs de taille égale
Généralement, un bloc fait entre **1kB** et **8kB**.

La commande :
```c
stat fichier
```

affiche la taille d'un bloc du FS où se trouve fichier.

![[Pasted image 20240926113138.png]]
# Interface périphérique bloc

> [!info] Abstraction
> On fait abstraction de la gestion du cache pour simplifier l'interface d'accès à un périphérique de type bloc

Après l'initialisation de la taille d'un bloc, chaque bloc est adressable logiquement via **son numéro** par une fonction d'écriture et une fonction de lecture :

```c
init_block_dev(dev,size)
read_blocks(dev, block_nb, buf, count)
write_blocks(dev, block_nb, buf, count)
```
# Adressage

Les blocs d'un périphérique de *taille N blocs* de *n bytes chacun*, sont adressables de *0 à N-1*. 
- **La lecture/écriture** se fait uniquement **par bloc, donc par unité de n bytes**
- **La lecture/écriture du bloc 0** traite les **bytes de l'offset `0` à l'offset `n−1`** du périphérique
- **La lecture/écriture du bloc b** traite les **bytes de l'offset `n∗b` à l'offset `n∗(b+1)−1`**
## Exemple
### Contexte

Vous avez un de 10MB ($10*1024*1024$ bytes). Chaque bloc du périphérique a une taille de 1024 bytes.
#### Quelle est l'intervalle des offsets des bytes du bloc numéro 17 ?

$[n*b,\ n*\left(b+1\right)-1] = [1024 * 17,\ 1024 * \left(17 + 1\right) - 1] = [17408,\ 18431]$ 
#### Dans quel bloc se trouve le byte localisé à l'offset 7000 du périphérique ? 

$\frac{\large{7000}}{\large{1024}} = 6.8359 = 6$
#### À quel offset du bloc est localisé le byte se trouvant à l'offset 7000 du périphérique ?

$7000 - 6 * 1024 = 856 = 7000\mod 1024$

![[Pasted image 20241008151349.png]]
# Abstraction

Avec cet adressage logique, on peut facilement émuler un périphérique bloc à partir d'un fichier image. (Traiter un fichier comme s'il s'agissait d'un périphérique de stockage).
Pour accéder aux données dans ce fichier image, on peut utiliser les appels système classiques **`read`** et **`write`**. Ces appels peuvent être mappés sur les fonctions de lecture et d'écriture de blocs, comme suit :

```c
init_block_dev(dev, size) -> fd = open(file)
read_blocks(dev, block_nb, buf, count) -> read(fd)
write_blocs(dev, block_nb, buf, count) -> write(fd)
```

Le fichier image peut être distant si on implémente l'abstraction au dessus des sockets et d'un protocole qui reste très simple :

```c
init_block_dev(dev, size) -> s = socket()
read_blocks(dev, block_nb, buf, count) -> read(s)
write_blocs(dev, block_nb, buf, count) -> write(s)
```