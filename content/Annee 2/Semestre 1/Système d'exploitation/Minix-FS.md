---
title: Minix-FS
draft: false
tags:
  - SysExploitation
---
---
# Introduction

Fait pas Andrew Tanenbaum. 
Le but était de répliquer la structure du FS de UNIX sans les fonctionnalités avancées et complexe, et fournir une aide à l’enseignement des FS et des OS
# Comparaison minix-fs et ext2/3/4

les [[Système de fichiers#UNIX et Blocs|blocs]] font tous 1kB c'est fixé !

![[Pasted image 20241010111621.png]]
## Deux variantes de MINIX-fs

1. Variante avec noms de fichiers de 14 caractères max (superblock magic value 0x137F)
2. Variante avec noms de fichiers de 30 caractères max (superblock magic value 0x138F)
# Structure générale sur disque de MINIX-fs v1.0

![[Pasted image 20241010112556.png]]
# Structure des [[Inodes|inodes]]

```c
struct minix_inode {
    u16 i_mode/;     // file type and permissions for file
    u16 i_uid;      // user id
    u32 i_size;     // file size in bytes
    u32 i_time;     // inode time
    u8 i_gid;       // group id
    u8 i_nlinks;    // number of dir entry pointing to
                    // this inode
    u16 i_zone[7];         // direct pointers
    u16 i_indir_zone;      // indirect pointer
    u16 i_dbl_indir_zone;  // double indirect pointer
};
```

> [!Warning] Important
> Structure sur disque stockée en *little-endian*
# Structure du mode du fichier
## Champs i_mode (16 bits)

![[Pasted image 20241010112844.png]]
# Structure des entrées de répertoires

```c
// Variante : superblock magic 0x137F
#define MINIX_NAME_LEN 14

struct minix_dir_entry {
    u16 inode;
    char name[MINIX_NAME_LEN];
};
```

Qu'elle est la taille d'un dir_entry en bytes ? 
$14 * sizeof(char) + 2= 16$ si $sizeof(char) = 1$
# Structure du superbloc

```c
struct minix_super_block {
    u16 s_ninodes;        // total number of inodes
    u16 s_nzones;         // total number of blocks (including superblock)
    u16 s_imap_blocks;    // inodes bitmap size in blocks
    u16 s_zmap_blocks;    // data blocks bitmap size in blocks
    u16 s_firstdatazone;  // index of first data block
    u16 s_log_zone_size;  // block size in bytes = 1024*2^s_log_zone_size
    u32 s_max_size;       // max file size in bytes
    u16 s_magic;          // 0x137f = v1 with 14 characters dir_entry
                          // 0x138f = v1 with 30 characters dir_entry
    u16 s_state;          // was the FS properly unmounted?
};
```

`u16 s_firstdatazone` est le numéro du premier bloc de donné
## Exemple de superbloc

Soit un disque de 20MB avec des blocs de 1kB. fs_blocks =  nombre de blocs total
Nombres d'inodes = (fs_block/3 + 32) & 0xFFFFFFE0

```c
struct minix_super_block {
    u16 s_ninodes = 6848;        // total number of inodes
    u16 s_nzones = 20480;        // total number of blocks
                                 // = (20*1024^2)/1024
    u16 s_imap_blocks = 1;       // inodes bitmap size in blocks
                                 // need 6848 bits
                                 // -> 1 block = 8192 bits
    u16 s_zmap_blocks = 3;       // data blocks bitmap size in blocks
                                 // need 20480 bits -> 3 blocks = 8192*3 bits
    u16 s_firstdatazone = 220;   // index of first data block
    u16 s_log_zone_size = 0;     // block size = 1024*2^s_log_zone_size
                                 // = 1024*2^0 = 1024
    u32 s_max_size = 268966912;  // max file size in bytes
                                 // = (7+(1024/2)+(1024/2)^2)*1024
    u16 s_magic = 0x137F;        // 0x137f Minix filesystem version 1
    u16 s_state = 1;             // was the FS properly unmounted?
};
```

max_size calcul division par 2 parce que le numéro de block est stocké sur 2 bytes.

![[Pasted image 20241010114230.png]]

Propriété de la racine du fichier qui a numéro d'inode spéciale : 1
=> Donc l'adresse 6 est l'adresse de l'inode 1 donc de la racine

ext4 reserve l'inode 1 pour les blocs de données corrompus sur le disque